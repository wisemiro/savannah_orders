// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
WITH inserted_order AS (
    INSERT INTO orders (created_at, total_amount, product_id, customer_id, quantity)
    VALUES (current_timestamp, $1, $2, $3, $4)
    RETURNING created_at, id, product_id, customer_id
)
SELECT 
    oi.created_at AS ordered_at,
    o.updated_at,
    o.deleted_at,
    o.total_amount,
    o.quantity,
    oi.product_id,
    oi.customer_id,
    p.name AS product_name,
    p.price,
    c.id AS customer_id,
    c.phone_number
FROM 
    inserted_order oi
LEFT JOIN 
    products p ON p.id = oi.product_id
LEFT JOIN 
    customers c ON c.id = oi.customer_id
LEFT JOIN 
    orders o ON o.id = oi.id
`

type CreateOrderParams struct {
	TotalAmount int32 `json:"total_amount"`
	ProductID   int64 `json:"product_id"`
	CustomerID  int64 `json:"customer_id"`
	Quantity    int32 `json:"quantity"`
}

type CreateOrderRow struct {
	OrderedAt    pgtype.Timestamptz `json:"ordered_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	TotalAmount  pgtype.Int4        `json:"total_amount"`
	Quantity     pgtype.Int4        `json:"quantity"`
	ProductID    int64              `json:"product_id"`
	CustomerID   int64              `json:"customer_id"`
	ProductName  pgtype.Text        `json:"product_name"`
	Price        pgtype.Int4        `json:"price"`
	CustomerID_2 pgtype.Int4        `json:"customer_id_2"`
	PhoneNumber  pgtype.Text        `json:"phone_number"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (*CreateOrderRow, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.TotalAmount,
		arg.ProductID,
		arg.CustomerID,
		arg.Quantity,
	)
	var i CreateOrderRow
	err := row.Scan(
		&i.OrderedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotalAmount,
		&i.Quantity,
		&i.ProductID,
		&i.CustomerID,
		&i.ProductName,
		&i.Price,
		&i.CustomerID_2,
		&i.PhoneNumber,
	)
	return &i, err
}

const getOrder = `-- name: GetOrder :one
select orders.id,
    orders.created_at as ordered_at,
    orders.updated_at,
    orders.deleted_at,
    orders.total_amount,
    orders.quantity,
    product.id,
    product.name,
    product.price,
    customer.id,
    customer.phone_number
from orders
    left join products product on product.id = orders.product_id
    left join customers customer on customer.id = orders.customer_id
where orders.id = $1
`

type GetOrderRow struct {
	ID          int32              `json:"id"`
	OrderedAt   pgtype.Timestamptz `json:"ordered_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	TotalAmount int32              `json:"total_amount"`
	Quantity    int32              `json:"quantity"`
	ID_2        pgtype.Int4        `json:"id_2"`
	Name        pgtype.Text        `json:"name"`
	Price       pgtype.Int4        `json:"price"`
	ID_3        pgtype.Int4        `json:"id_3"`
	PhoneNumber pgtype.Text        `json:"phone_number"`
}

func (q *Queries) GetOrder(ctx context.Context, id int32) (*GetOrderRow, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i GetOrderRow
	err := row.Scan(
		&i.ID,
		&i.OrderedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotalAmount,
		&i.Quantity,
		&i.ID_2,
		&i.Name,
		&i.Price,
		&i.ID_3,
		&i.PhoneNumber,
	)
	return &i, err
}

const listOrders = `-- name: ListOrders :many
select orders.id,
    orders.created_at as ordered_at,
    orders.updated_at,
    orders.deleted_at,
    orders.total_amount,
    orders.quantity,
    product.id,
    product.name,
    product.price,
    customer.id,
    customer.phone_number
from orders
    left join products product on product.id = orders.product_id
    left join customers customer on customer.id = orders.customer_id
`

type ListOrdersRow struct {
	ID          int32              `json:"id"`
	OrderedAt   pgtype.Timestamptz `json:"ordered_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	TotalAmount int32              `json:"total_amount"`
	Quantity    int32              `json:"quantity"`
	ID_2        pgtype.Int4        `json:"id_2"`
	Name        pgtype.Text        `json:"name"`
	Price       pgtype.Int4        `json:"price"`
	ID_3        pgtype.Int4        `json:"id_3"`
	PhoneNumber pgtype.Text        `json:"phone_number"`
}

func (q *Queries) ListOrders(ctx context.Context) ([]*ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalAmount,
			&i.Quantity,
			&i.ID_2,
			&i.Name,
			&i.Price,
			&i.ID_3,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
select orders.id,
    orders.created_at as ordered_at,
    orders.updated_at,
    orders.deleted_at,
    orders.total_amount,
    orders.quantity,
    product.id,
    product.name,
    product.price,
    customer.id,
    customer.phone_number
from orders
    left join products product on product.id = orders.product_id
    left join customers customer on customer.id = orders.customer_id
where orders.customer_id = $1
`

type ListOrdersByCustomerRow struct {
	ID          int32              `json:"id"`
	OrderedAt   pgtype.Timestamptz `json:"ordered_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	TotalAmount int32              `json:"total_amount"`
	Quantity    int32              `json:"quantity"`
	ID_2        pgtype.Int4        `json:"id_2"`
	Name        pgtype.Text        `json:"name"`
	Price       pgtype.Int4        `json:"price"`
	ID_3        pgtype.Int4        `json:"id_3"`
	PhoneNumber pgtype.Text        `json:"phone_number"`
}

func (q *Queries) ListOrdersByCustomer(ctx context.Context, customerID int64) ([]*ListOrdersByCustomerRow, error) {
	rows, err := q.db.Query(ctx, listOrdersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListOrdersByCustomerRow{}
	for rows.Next() {
		var i ListOrdersByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalAmount,
			&i.Quantity,
			&i.ID_2,
			&i.Name,
			&i.Price,
			&i.ID_3,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :exec
update orders
set total_amount = $1
where id = $2
    and deleted_at is null
`

type UpdateOrderParams struct {
	TotalAmount int32 `json:"total_amount"`
	ID          int32 `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.Exec(ctx, updateOrder, arg.TotalAmount, arg.ID)
	return err
}
